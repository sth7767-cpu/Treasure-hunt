import os
import time
import shutil
import sys
import random

# Windows CMDì—ì„œ í‚¤ì…ë ¥ ë°›ê¸°
import msvcrt

# CMD í™˜ê²½ ê°•ì œ ì‹¤í–‰ ë¡œì§ (ê¸°ì¡´ê³¼ ë™ì¼)
if os.environ.get("RUN_IN_CMD") != "1":
    os.environ["RUN_IN_CMD"] = "1"
    os.system(f'start cmd /k "{sys.executable} {__file__}"')
    sys.exit()

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def get_big_start_text():
    return r"""
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   
â•šâ•â•â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•‘   
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   
â•šâ•â•â•â•â•â•â•   â•šâ•â•   â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   
    """

def get_big_end_text():
    return r"""
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— 
â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—
â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘
 â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•     â•šâ•â•â•â•â•â•   â•šâ•â•â•â•  â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•
    """

def print_centered(text):
    columns, lines = shutil.get_terminal_size()
    text_lines = text.strip().split('\n')
    vertical_padding = (lines - len(text_lines)) // 2
    print('\n' * max(0, vertical_padding))
    for line in text_lines:
        print(line.center(columns))

def get_score(start_time):
    return int(time.time() - start_time)

def screen_one():
    clear_screen()
    print_centered(get_big_start_text())
    columns, _ = shutil.get_terminal_size()
    print("\n" + "ì ì‹œ í›„ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤...".center(columns))
    time.sleep(2)
    screen_two()

def read_key_nonblocking():
    """ë°©í–¥í‚¤/AD ì…ë ¥ì„ ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ ì½ìŒ"""
    if not msvcrt.kbhit():
        return None
    ch = msvcrt.getwch()
    if ch in ('a', 'A'):
        return 'LEFT'
    if ch in ('d', 'D'):
        return 'RIGHT'
    if ch == '\x1b':  # ESC
        return 'ESC'
    if ch == '\x00' or ch == '\xe0':  # ë°©í–¥í‚¤ prefix
        ch2 = msvcrt.getwch()
        if ch2 == 'K':
            return 'LEFT'
        if ch2 == 'M':
            return 'RIGHT'
    return None

def find_track_bounds(line, walls_set):
    """í•œ ì¤„ì—ì„œ íŠ¸ë™ì˜ ì™¼/ì˜¤ë¥¸ìª½ ë²½ ìœ„ì¹˜ë¥¼ ì°¾ìŒ(ì—†ìœ¼ë©´ None)"""
    left = None
    right = None
    for i, c in enumerate(line):
        if c in walls_set:
            left = i
            break
    for i in range(len(line) - 1, -1, -1):
        if line[i] in walls_set:
            right = i
            break
    if left is None or right is None or right <= left:
        return None
    return left, right

def screen_two():
    clear_screen()
    filename = "../track.txt"  # í•„ìš”í•˜ë©´ ê²½ë¡œ ìˆ˜ì •
    if not os.path.exists(filename):
        print(f"ì˜¤ë¥˜: {filename} íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        return

    with open(filename, 'r', encoding='utf-8') as f:
        raw_lines = [ln.rstrip('\n') for ln in f.readlines()]

    total_lines = len(raw_lines)
    view_height = 20

    # ì°¨ê°€ "ê³„ì† ìœ„ì—" ìˆê²Œ
    PLAYER_ROW = 2  # 0ì´ ë§¨ ìœ„

    # íŠ¸ë™ ë²½ ë¬¸ìë“¤
    walls = ["â”‚", "â”ƒ", "|", "â•²", "â•±", "\\", "/"]
    walls_set = set(walls)

    # ì•„ì´í…œ í’€
    ITEM_POOL = [
        {"name": "ë¬´ì ", "effect": "invincible", "symbol": "â˜…"},
        {"name": "2ë°° ì ìˆ˜", "effect": "double_score", "symbol": "â—†"},
        {"name": "ë³´ë„ˆìŠ¤", "effect": "bonus", "symbol": "â™¥"},
    ]

    # ì•„ì´í…œ ì¢Œí‘œ ì €ì¥: abs_line -> {"x": int, "item": {...}}
    item_spots = {}

    # =========================
    # âœ… ì•„ì´í…œ ìƒì„±: "8í–‰ë§ˆë‹¤ ì¤‘ì•™" (ê¸°ì¡´ + ìƒì„± ë¡œì§ì„ ì•„ì´í…œìœ¼ë¡œ)
    # - ë¼ì¸ì— ì§ì ‘ ë°•ì§€ ì•ŠìŒ! (ì˜¤ë²„ë ˆì´ë¡œ ê·¸ë¦´ ê±°ë¼ì„œ)
    # =========================
    for idx, line in enumerate(raw_lines):
        if idx % 8 == 0 and idx > 0 and "â•" not in line:
            bounds = find_track_bounds(line, walls_set)
            if bounds:
                left, right = bounds
                center = (left + right) // 2
                if 0 <= center < len(line) and line[center] == ' ':
                    item = random.choice(ITEM_POOL)
                    item_spots[idx] = {"x": center, "item": item}

    # =========================
    # íš¨ê³¼ ìƒíƒœ
    # =========================
    start_time = time.time()
    score_bonus = 0
    double_score_until = 0.0
    invincible_until = 0.0

    # =========================
    # ì°¨ ì´ˆê¸° ìœ„ì¹˜: ì²« í”„ë ˆì„ì˜ PLAYER_ROWì—ì„œ íŠ¸ë™ ì¤‘ì•™ìœ¼ë¡œ
    # =========================
    initial_i = 0
    base_line_for_car = raw_lines[min(initial_i + PLAYER_ROW, total_lines - 1)]
    bounds = find_track_bounds(base_line_for_car, walls_set)
    if bounds:
        left, right = bounds
        car_x = (left + right) // 2
    else:
        car_x = len(base_line_for_car) // 2

    # ìŠ¤í¬ë¡¤ ì†ë„(ë„ˆë¬´ ë¹¨ë¦¬ ì‚¬ë¼ì§€ëŠ” ëŠë‚Œì´ë©´ ì—¬ê¸° ì˜¬ë¦¬ë©´ ë¨)
    # frame_skipì„ 2ë¡œ í•˜ë©´ "í•œ ì¤„ì„ 2í”„ë ˆì„ ë™ì•ˆ ë³´ì—¬ì¤˜ì„œ" ë” ì²œì²œíˆ ì˜¬ë¼ì˜´
    frame_skip = 2

    print("3ì´ˆ í›„ ë ˆì´ì‹±ì„ ì‹œì‘í•©ë‹ˆë‹¤! (A/D ë˜ëŠ” â†/â†’ ì´ë™, ESC ì¢…ë£Œ)")
    time.sleep(3)

    try:
        i = 0
        while i <= total_lines - view_height:
            clear_screen()
            elapsed = time.time() - start_time

            # ê¸°ë³¸ ë”œë ˆì´(ì›ë˜ë³´ë‹¤ ì‚´ì§ ëŠë¦¬ê²Œ)
            delay = 0.08 if elapsed < 15 else 0.05 if elapsed < 30 else 0.03

            # ====== ì…ë ¥ ì²˜ë¦¬ ======
            key = read_key_nonblocking()
            if key == 'ESC':
                print("ESCë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.")
                time.sleep(0.5)
                break

            # í˜„ì¬ í”Œë ˆì´ì–´ ë¼ì¸ì˜ íŠ¸ë™ ê²½ê³„ë¡œ ì°¨ ì´ë™ ì œí•œ
            player_line_abs = i + PLAYER_ROW
            if 0 <= player_line_abs < total_lines:
                bounds = find_track_bounds(raw_lines[player_line_abs], walls_set)
                if bounds:
                    left, right = bounds
                    min_x = left + 1
                    max_x = right - 1
                    if key == 'LEFT':
                        car_x -= 1
                    elif key == 'RIGHT':
                        car_x += 1
                    if car_x < min_x:
                        car_x = min_x
                    if car_x > max_x:
                        car_x = max_x
                else:
                    # ê²½ê³„ ëª» ì°¾ìœ¼ë©´ ê·¸ëƒ¥ ì¢Œìš°ë§Œ
                    if key == 'LEFT':
                        car_x -= 1
                    elif key == 'RIGHT':
                        car_x += 1
                    car_x = max(0, min(car_x, len(raw_lines[player_line_abs]) - 1))

            # ====== ë Œë” ë·° ë§Œë“¤ê¸° (ë³µì‚¬í•´ì„œ ì˜¤ë²„ë ˆì´) ======
            current_view = raw_lines[i: i + view_height]
            render = [list(line) for line in current_view]

            # ====== ì•„ì´í…œ ì˜¤ë²„ë ˆì´: í™”ë©´ì— ë“¤ì–´ì˜¨ ì•„ì´í…œë§Œ ê·¸ë¦¬ê¸° ======
            for abs_line, obj in list(item_spots.items()):
                if i <= abs_line < i + view_height:
                    row = abs_line - i
                    x = obj["x"]
                    if 0 <= row < view_height and 0 <= x < len(render[row]):
                        # íŠ¸ë™ ìœ„ì—ë§Œ ì°íˆê²Œ í•˜ê³  ì‹¶ìœ¼ë©´ ê³µë°±ì¼ ë•Œë§Œ ì°ê¸°
                        if render[row][x] == ' ':
                            render[row][x] = obj["item"]["symbol"]

                # í™”ë©´ì„ ì™„ì „íˆ ì§€ë‚˜ê°€ì„œ(í”Œë ˆì´ì–´ë³´ë‹¤ í›¨ì”¬ ìœ„ë¡œ) ë‹¤ì‹œëŠ” ëª» ë¨¹ëŠ” ì•„ì´í…œì€ ì •ë¦¬
                if abs_line < i - 2:
                    del item_spots[abs_line]

            # ====== ì°¨ ì˜¤ë²„ë ˆì´ (í•­ìƒ ê³ ì •) ======
            car_symbol = 'A'  # ì›í•˜ë©´ 'ğŸš—'ë¡œ ë°”ê¿”ë„ ë¨(í­ ë¬¸ì œ ìƒê¸¸ ìˆ˜ ìˆìŒ)
            row = PLAYER_ROW
            if 0 <= row < view_height and 0 <= car_x < len(render[row]):
                render[row][car_x] = car_symbol

            # ====== ì¶©ëŒ(íšë“): "ì°¨ ìœ„ì¹˜"ì™€ ê°™ì€ ì¤„/ê°™ì€ xì¸ ì•„ì´í…œë§Œ ë¨¹ê¸° ======
            now = time.time()
            if player_line_abs in item_spots:
                obj = item_spots[player_line_abs]
                if obj["x"] == car_x:
                    item = obj["item"]
                    del item_spots[player_line_abs]

                    if item["effect"] == "bonus":
                        score_bonus += 10
                    elif item["effect"] == "double_score":
                        double_score_until = now + 5.0
                    elif item["effect"] == "invincible":
                        invincible_until = now + 5.0

            # ====== ì¶œë ¥ ======
            for row_chars in render:
                print(''.join(row_chars))

            base_score = get_score(start_time)
            shown_score = base_score
            tags = []

            if now < double_score_until:
                shown_score = base_score * 2
                tags.append("SCORE x2")

            if now < invincible_until:
                tags.append("ë¬´ì ")

            shown_score += score_bonus
            tag_str = (" | ìƒíƒœ: " + ", ".join(tags)) if tags else ""
            print("-" * 60)
            print(f"[í˜„ì¬ ì ìˆ˜: {shown_score}]{tag_str}  (A/D ë˜ëŠ” â†/â†’ ì´ë™, ESC ì¢…ë£Œ)")

            time.sleep(delay)

            # ====== ìŠ¤í¬ë¡¤ ì§„í–‰(ì•„ì´í…œì´ ë” ì˜¤ë˜ ë³´ì´ê²Œ) ======
            # frame_skip=2ë©´ ië¥¼ 2í”„ë ˆì„ì— 1ë²ˆë§Œ ì˜¬ë ¤ì„œ "ë” ì²œì²œíˆ ì˜¬ë¼ì˜¤ëŠ” ëŠë‚Œ"
            for _ in range(frame_skip - 1):
                # ê°™ì€ ië¡œ í•œ í”„ë ˆì„ ë” ë³´ì—¬ì£¼ê¸°
                key2 = read_key_nonblocking()
                if key2 == 'ESC':
                    return screen_three()
                time.sleep(delay)

            i += 1

        print("\n\n=== GOAL ì§€ì ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤! ===")
        time.sleep(2)

    except KeyboardInterrupt:
        print("\nê²Œì„ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")

    screen_three()

def screen_three():
    clear_screen()
    print_centered(get_big_end_text())
    columns, _ = shutil.get_terminal_size()
    print("\n" + "ê²Œì„ì„ ë‹¤ì‹œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (Y/N)".center(columns))
    while True:
        choice = input("ì„ íƒ > ".center(columns // 2)).strip().upper()
        if choice == 'Y':
            screen_two()
            return
        elif choice == 'N':
            sys.exit()

if __name__ == "__main__":
    screen_one()
